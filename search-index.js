var searchIndex = {};
searchIndex['wcstr'] = {"items":[[0,"","wcstr","Rust FFI helpers for working with win32 API's \"Unicode\" functions that uses \"wide\" strings.",null,null],[3,"NulError","","An error returned when an unexpected nul is found in the string, slice or vector provided.",null,null],[3,"NoNulError","","An error returned when an expected nul is not found in the string, slice or vector provided.",null,null],[3,"WCStr","","Representation of a borrowed Win32 style \"wide\" string.",null,null],[3,"WCString","","A type representing an owned Win32 style \"wide\" string.",null,null],[3,"Split","","Created with method ```.split(delim)```",null,null],[11,"hash","","",0,null],[11,"cmp","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"wcstr"},{"name":"wcstr"}],"output":{"name":"bool"}}],[11,"from_raw_parts","","Create a ```&WCStr``` from a raw pointer and a length.",0,null],[11,"from_slice_with_nul","","Create a ```&WCStr``` from a slice of ```u16```'s.\nThis function will scan the slice for ```nul``` and assume that ```nul``` terminates the string.\nIf no ```nul``` is found in the slice, it will return ```Err(NoNulError(None))```\n# ```frm_slice_with_nul()``` example",0,null],[11,"len","","length of the string in u16 units",0,{"inputs":[{"name":"wcstr"}],"output":{"name":"usize"}}],[11,"as_ptr","","Return a raw pointer to this \"wide\" string.",0,null],[11,"to_slice","","Return this \"wide\" string as a slice of ```u16```s without a ```nul``` terminator.",0,null],[11,"to_slice_with_nul","","Return this \"wide\" string as a slice of ```u16```s with a ```nul``` terminator.",0,null],[11,"to_string","","Convert this \"wide\" string to a ```String``` by using ```String::from_utf16```",0,{"inputs":[{"name":"wcstr"}],"output":{"name":"result"}}],[11,"to_string_lossy","","Convert this \"wide\" string to a ```String``` by using ```String::from_utf16_lossy```",0,{"inputs":[{"name":"wcstr"}],"output":{"name":"string"}}],[11,"to_os_string","","Convert this \"wide\" string to an ```OsString``` by using ```OsString::from_wide```",0,{"inputs":[{"name":"wcstr"}],"output":{"name":"osstring"}}],[11,"fmt","","",0,{"inputs":[{"name":"wcstr"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"as_ref","","",0,{"inputs":[{"name":"wcstr"}],"output":{"name":"wcstr"}}],[11,"as_ref","","",0,null],[11,"to_owned","","",0,{"inputs":[{"name":"wcstr"}],"output":{"name":"wcstring"}}],[11,"clone","","",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"wcstring"}}],[11,"hash","","",1,null],[11,"cmp","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"bool"}}],[11,"eq","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"wcstring"},{"name":"wcstring"}],"output":{"name":"bool"}}],[11,"new","","Create an empty ```WCString```.\n# ```new()``` example\n    use wcstr::WCString;\n    let s = WCString::new();\n    assert!(s.len() == 0);",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"wcstring"}}],[11,"from_vec","","Create a ```WCString``` from a ```Vec<u16>```.\nThe string will be scanned for nul and NulError will be returned if a nul is found.\n# ```from_vec()``` example\n    use wcstr::WCString;\n    use std::os::windows::ffi::OsStrExt;\n    use std::ffi::OsStr;\n    let v: Vec<_> = OsStr::new(\"testing\").encode_wide().collect();\n    let s = WCString::from_vec(v).unwrap();\n    assert!(s.len() == 7);",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"from_vec_with_nul","","Create a WCString from a Vec<u16> with a nul terminator.\nThe string will be scanned for nul.\nThe string will be truncated at the position where nul is found.\nNoNulError will be returned if a nul could not be found.\n# ```from_vec_with_nul()``` example\n    use wcstr::WCString;\n    use std::os::windows::ffi::OsStrExt;\n    use std::ffi::OsStr;\n    let v: Vec<_> = OsStr::new(\"testing\\0\").encode_wide().collect();\n    let s = WCString::from_vec_with_nul(v).unwrap();\n    assert!(s.len() == 7);",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"from_vec_unchecked","","Create a WCString from a Vec<u16> without checking for validity.\nThis function is unsafe as it assumes that the string passed in has no nul in it.\n# ```from_vec_unchecked()``` example\n    use wcstr::WCString;\n    use std::os::windows::ffi::OsStrExt;\n    use std::ffi::OsStr;\n    let v: Vec<_> = OsStr::new(\"testing\").encode_wide().collect();\n    let s = unsafe { WCString::from_vec_unchecked(v) };\n    assert!(s.len() == 7);",1,{"inputs":[{"name":"wcstring"},{"name":"vec"}],"output":{"name":"wcstring"}}],[11,"from_vec_with_nul_unchecked","","Create a WCString from a Vec<u16> with a nul terminator without checking for validity.\nThis function is unsafe for the following reasons:\n * This function assumes that the string passed in has no nul in it aside from the nul\n terminator.\n * This function assumes that the string passed in has a nul terminator at the end.\n# ```from_vec_with_nul_unchecked()``` example\n    use wcstr::WCString;\n    use std::os::windows::ffi::OsStrExt;\n    use std::ffi::OsStr;\n    let v: Vec<_> = OsStr::new(\"testing\\0\").encode_wide().collect();\n    let s = unsafe { WCString::from_vec_with_nul_unchecked(v) };\n    assert!(s.len() == 7);",1,{"inputs":[{"name":"wcstring"},{"name":"vec"}],"output":{"name":"wcstring"}}],[11,"from_str","","Create a WCString from a &OsStr (or anything that can be cast to &OsStr, including OsString, &str and String)\nThe string will be scanned for nul and NulError will be returned if a nul is found.\n# ```from_str()``` example\n    use wcstr::WCString;\n    let s = WCString::from_str(\"testing\").unwrap();\n    assert!(s.len() == 7);",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"from_str_with_nul","","Create a WCString from a &OsStr with a nul terminator (or anything that can be cast to &OsStr, including OsString, &str and String)\nThe string will be scanned for nul and NoNulError will be returned if a nul could not be\nfound. The string will be truncated at the position where nul is found.\n# ```from_str_with_nul()``` example\n    use wcstr::WCString;\n    let s = WCString::from_str_with_nul(\"testing\\0\").unwrap();\n    assert!(s.len() == 7);",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"into_vec","","Return the underlying buffer as a Vec<u16>.\nThe WCString will be consumed.\nThe returned buffer does not contain the nul terminator.\nThe returned buffer does not contain any nul.\n# ```into_vec()``` example\n    use wcstr::WCString;\n    let s = WCString::from_str(\"testing\").unwrap();\n    let v = s.into_vec();\n    assert!(*v.last().unwrap() != 0);",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"vec"}}],[11,"into_vec_with_nul","","Return the underlying buffer as a Vec<u16> with a nul terminator.\nThe WCString will be consumed.\nThe returned buffer does not contain any nul aside from the nul terminator.\n# ```into_vec_with_nul()``` example\n    use wcstr::WCString;\n    let s = WCString::from_str(\"testing\").unwrap();\n    let v = s.into_vec_with_nul();\n    assert!(*v.last().unwrap() == 0);",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"vec"}}],[11,"as_slice","","Return the underlying buffer as a u16 slice.\nThe returned slice does not contain the nul terminator.\nThe returned slice does not contain any nul.\n# ```as_slice()``` example\n    use wcstr::WCString;\n    let s = WCString::from_str(\"testing\").unwrap();\n    let w = s.as_slice();\n    assert!(*w.last().unwrap() != 0);",1,null],[11,"as_slice_with_nul","","Return the underlying buffer as a u16 slice with a nul terminator.\nThe returned slice does not contain any nul aside from the nul terminator.\n# ```as_slice_with_nul()``` example\n    use wcstr::WCString;\n    let s = WCString::from_str(\"testing\").unwrap();\n    let w = s.as_slice_with_nul();\n    assert!(*w.last().unwrap() == 0);",1,null],[11,"as_wcstr","","Return this string as a &WCStr\n# ```as_wcstr()``` example\n    use wcstr::WCString;\n    let s = WCString::from_str(\"testing\").unwrap();\n    let w = s.as_wcstr();",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"wcstr"}}],[11,"push","","Push/Append a &WCStr (or anything that can cast to a &WCStr, like another WCString).\n# ```push()``` example\n    use wcstr::WCString;\n    let mut s = WCString::new();\n    let t = WCString::from_str(\"test\").unwrap();\n    s.push(&t);\n    s.push(&t);",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":null}],[11,"push_slice","","Push/Append a u16 slice.\nThe slice will be scanned for nul, and the push will fail with NulError if a nul is found.\n# ```push_slice()``` example\n    use wcstr::WCString;\n    let mut s = WCString::new();\n    let t = WCString::from_str(\"test\").unwrap();\n    let t = t.as_slice();\n    s.push_slice(t).unwrap();\n    s.push_slice(t).unwrap();",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"push_slice_with_nul","","Push/Append a u16 slice with a nul terminator.\nThe slice will be scanned for nul, and the push will fail with NoNulError if a nul is not\nfound.\nThe push will stop at the first nul found in the slice.\n# ```push_slice_with_nul()``` example\n    use wcstr::WCString;\n    let mut s = WCString::new();\n    let t = WCString::from_str(\"test\").unwrap().into_vec_with_nul();\n    s.push_slice_with_nul(&t).unwrap();\n    s.push_slice_with_nul(&t).unwrap();",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"push_str","","Push/Append a &OsStr (or anything that can be cast to &OsStr)\nThe string will be scanned for nul, and the push will fail with NulError if a nul is found.\n# ```push_str()``` example\n    use wcstr::WCString;\n    let mut s = WCString::new();\n    s.push_str(\"test1\").unwrap();\n    s.push_str(\"test2\").unwrap();",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"push_str_with_nul","","Push/Append a &OsStr (or anything that can be cast to &OsStr)\nThe string will be scanned for nul, and the push will fail with NoNulError if a nul is not\nfound.\nThe push will stop at the first nul found in the string.\n# ```push_str_with_nul()``` example\n    use wcstr::WCString;\n    let mut s = WCString::new();\n    s.push_str_with_nul(\"test1\\0everything after nul will be ignored\").unwrap();\n    s.push_str_with_nul(\"test2\\0\").unwrap();",1,{"inputs":[{"name":"wcstring"},{"name":"t"}],"output":{"name":"result"}}],[11,"split","","Split the string into multiple ```&mut WCStr``` using a delimiter.",1,{"inputs":[{"name":"wcstring"},{"name":"u16"}],"output":{"name":"split"}}],[11,"deref","","",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"wcstr"}}],[11,"fmt","","",1,{"inputs":[{"name":"wcstring"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"as_ref","","",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"wcstr"}}],[11,"as_ref","","",1,null],[11,"borrow","","",1,{"inputs":[{"name":"wcstring"}],"output":{"name":"wcstr"}}],[11,"fmt","","",2,{"inputs":[{"name":"split"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"iter","","Get iterator.",2,{"inputs":[{"name":"split"}],"output":{"name":"split"}}],[11,"as_mut","","",2,{"inputs":[{"name":"split"}],"output":{"name":"split"}}],[11,"fmt","","",3,{"inputs":[{"name":"nulerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"nulerror"},{"name":"nulerror"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"nulerror"},{"name":"nulerror"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"nulerror"}],"output":{"name":"nulerror"}}],[11,"fmt","","",4,{"inputs":[{"name":"nonulerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"nonulerror"},{"name":"nonulerror"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"nonulerror"},{"name":"nonulerror"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"nonulerror"}],"output":{"name":"nonulerror"}}],[11,"nul_position","","Return the position of the nul in u16 units.",3,{"inputs":[{"name":"nulerror"}],"output":{"name":"usize"}}],[11,"into_vec","","Consume this error, returning the underlying Vec<u16> that contain the nul.\nThis will provide the underlying Vec<u16> only when a Vec<u16> is passed in as a parameter\nand only when that Vec<u16> is consumed. Otherwise, this function returns None.",3,{"inputs":[{"name":"nulerror"}],"output":{"name":"option"}}],[11,"fmt","","",3,{"inputs":[{"name":"nulerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",3,{"inputs":[{"name":"nulerror"}],"output":{"name":"str"}}],[11,"into_vec","","Consume this error, returning the underlying Vec<u16> that does not contain a nul.\nThis will provide the underlying Vec<u16> only when a Vec<u16> is passed in as a parameter\nand only when that Vec<u16> is consumed. Otherwise, this function returns None.",4,{"inputs":[{"name":"nonulerror"}],"output":{"name":"option"}}],[11,"fmt","","",4,{"inputs":[{"name":"nonulerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",4,{"inputs":[{"name":"nonulerror"}],"output":{"name":"str"}}]],"paths":[[3,"WCStr"],[3,"WCString"],[3,"Split"],[3,"NulError"],[3,"NoNulError"]]};
initSearch(searchIndex);
